6. Gestión del Estado
La "Pantalla: Dashboard Principal (Vista General)" actúa como un centro de control dinámico que muestra datos relevantes en tiempo real y proporciona puntos de entrada intuitivos a todas las funcionalidades principales del sistema. Para que la interfaz de usuario (UI) se mantenga sincronizada y reactiva a las acciones del usuario, es fundamental una buena gestión del estado. Dado que el frontend del Dashboard se desarrollará con frameworks como React, Vue.js o similares, la elección de una estrategia de gestión del estado es vital.
Elección de una librería o patrón para la gestión del estado global de la aplicación: Aunque los documentos no especifican una librería concreta, la necesidad de una UI reactiva y sincronizada sugiere la implementación de patrones de gestión de estado robustos.
• Para un frontend basado en React, se podrían considerar:
    ◦ Context API + useReducer: Una solución nativa de React adecuada para la gestión de estados globales de complejidad media. Es ideal para datos de usuario autenticado o estados de modales/paneles que necesitan ser accesibles por muchos componentes sin una prop drilling excesiva.
    ◦ Redux (con Redux Toolkit) o Zustand: Para escenarios de mayor complejidad, donde la gestión de datos asíncronos (llamadas a la API) y la necesidad de un flujo de datos predecible sean prioritarias. Proporciona una "fuente única de verdad" para el estado global y herramientas potentes para depuración y escalabilidad.
• Para un frontend basado en Vue.js, se podrían considerar:
    ◦ Vuex o Pinia: Los gestores de estado oficiales de Vue.js. Proporcionan un almacén centralizado de estado que facilita la reactividad y la depuración, siendo esenciales para aplicaciones Vue a gran escala.
La elección específica dependerá de la complejidad exacta de la lógica de negocio y el volumen de datos que se esperen manejar en tiempo real. Para un "Núcleo Administrativo Central", que es la "columna vertebral y la base de datos central de todo el ecosistema", una solución más estructurada como Redux/Vuex/Pinia podría ofrecer mayor mantenibilidad y escalabilidad a largo plazo.
Descripción de las partes principales del estado que necesitarán ser gestionadas globalmente: Para el Dashboard, varias piezas de información son críticas y requerirán un estado global para garantizar la coherencia y la reactividad:
• Datos del Usuario Autenticado y su Rol: La cabecera del dashboard mostrará el usuario logueado y su rol, y la barra de navegación lateral presentará las secciones a las que tiene acceso según sus permisos. Esta información es fundamental para la adaptación de la interfaz y el control de acceso basado en roles.
• Estado de Carga y Error Global de APIs: Las comunicaciones con el backend pueden presentar "problemas de conectividad" o "errores de servidor". Es crucial tener un estado global para indicar cuándo se están realizando llamadas a la API (estado loading, para mostrar spinners o deshabilitar botones) y cuándo ha ocurrido un error (estado error, para mostrar mensajes de error genéricos).
• Datos de la Tabla de Pacientes y Otros Datos Dinámicos: La sección "PACIENTES RECIENTES" y las "CITAS DEL DÍA" muestran datos dinámicos que se actualizan en tiempo real o casi real. Estos datos, junto con las "MÉTRICAS RÁPIDAS", deben ser parte del estado global para que cualquier componente que los necesite pueda acceder a ellos de forma consistente.
• Estado de Visibilidad de Modales/Paneles: Si bien no se menciona explícitamente en los documentos, una interfaz de usuario compleja como el Dashboard a menudo utiliza modales o paneles laterales (como los de filtrado o creación de nuevos registros) cuya visibilidad puede ser gestionada a nivel global para una mejor coordinación entre componentes.
• Contenido de Texto Generado por IA: Las funcionalidades de Inteligencia y Automatización Integrada permiten generar texto (ej., borradores de correos, resúmenes de texto). Este contenido, antes de ser utilizado o guardado, podría residir temporalmente en el estado global.
Cómo se actualizará y accederá al estado desde diferentes componentes: La forma en que se actualiza y accede al estado dependerá del patrón o librería de gestión de estado elegida:
• Actualización:
    ◦ Acciones/Despachos: En patrones como Redux o Vuex, los componentes "despachan" (dispatch) acciones. Estas acciones son objetos que describen lo que sucedió (ej., USER_LOGIN_SUCCESS, FETCH_PATIENTS_START, FETCH_PATIENTS_SUCCESS). Los "reducers" (en Redux) o "mutations" (en Vuex) son funciones puras que toman el estado actual y una acción, y devuelven un nuevo estado, asegurando un flujo de datos unidireccional y predecible.
    ◦ Actualizadores de estado: Para Context API + useReducer, se utilizan funciones dispatch para enviar acciones al reducer. Para estados locales o de menor alcance, se usarán funciones setState de React o ref/reactive de Vue.
• Acceso:
    ◦ Selectores/Hooks: Los componentes accederán a porciones específicas del estado global mediante "selectores" (en Redux) o "hooks personalizados" (en React con Context/Zustand), o mediante funciones mapState o useStore (en Vuex/Pinia). Esto les permite "suscribirse" solo a la parte del estado que les interesa y re-renderizarse solo cuando esa parte cambia, optimizando el rendimiento.
7. Consumo de APIs del Backend
El Dashboard de Escritorio se comunica con el "Servidor de Aplicación (Backend)" a través de APIs RESTful. Este backend está alojado en Google Cloud Platform (GCP) y maneja la lógica de negocio, la interacción con la base de datos y otros servicios.
Estrategia para realizar las llamadas a los endpoints del backend desde el frontend: Se recomienda una estrategia que garantice la robustez, mantenibilidad y seguridad de las comunicaciones:
• Módulo de Servicios Dedicado: En lugar de realizar llamadas fetch o axios directamente desde los componentes, se creará un módulo de servicios o una capa de abstracción para las APIs. Este módulo contendría funciones específicas para cada endpoint (ej., api.getPatients(), api.createPatient(data), api.login(credentials)).
    ◦ Librería HTTP: Se puede utilizar fetch (API nativa del navegador) o una librería popular como axios. axios es preferible por su simplicidad, manejo automático de JSON, intercepción de solicitudes/respuestas y mejor manejo de errores.
• Endpoints: Se deben desarrollar endpoints de API robustos para las diferentes funcionalidades del Dashboard, como:
    ◦ GET /patients con parámetros de paginación, búsqueda y filtrado.
    ◦ POST /patients para crear nuevos registros.
    ◦ PUT /patients/{id} para actualizar.
    ◦ DELETE /patients/{id} para el borrado suave (soft delete).
    ◦ Endpoints específicos para la galería de archivos y las interacciones con el asistente virtual de IA.
    ◦ POST /api/v1/auth/login para la autenticación.
Cómo se manejarán los estados de carga (loading), error (error), y éxito (data) de las llamadas a la API en la interfaz de usuario: La gestión visual de estos estados es crucial para una buena experiencia de usuario:
• Estado de Carga (loading):
    ◦ Indicadores Visuales: Durante las solicitudes a la API, la UI mostrará indicadores de carga (ej., spinners, esqueletos de contenido, o deshabilitación de botones) para comunicar al usuario que la operación está en curso y que el sistema no está "congelado". Esto es especialmente relevante cuando hay "problemas de conectividad" o el "servidor no puede comunicarse".
• Estado de Error (error):
    ◦ Mensajes Clares y Concisos: En caso de fallos en la API (ej., credenciales incorrectas, campos vacíos, o errores de servidor), se mostrarán "mensajes de error claros y concisos" al usuario. Estos mensajes pueden ser notificaciones flotantes, textos debajo de los campos de formulario, o alertas modales.
    ◦ Registro en Logs: Los errores del frontend también podrían registrarse en el "Servicio de Logs de Auditoría" si son críticos, para monitorear problemas de rendimiento o seguridad.
• Estado de Éxito (data):
    ◦ Actualización Reactiva de la UI: Una vez que una llamada a la API es exitosa, los datos recibidos se utilizarán para actualizar el estado global o local pertinente. Esto provocará que los componentes relevantes se re-rendericen automáticamente, mostrando la información actualizada (ej., una nueva entrada en el historial clínico, un nuevo paciente en la tabla, o un cambio de estado en una cita).
Cómo se gestionarán los tokens de autenticación: La seguridad de las credenciales es una "preocupación de seguridad de datos" clave. El proceso de login autentica al usuario y aplica el control de acceso basado en roles. La comunicación se realiza mediante HTTPS (TLS 1.3) para cifrar los datos en tránsito.
• Generación del Token: Tras un login exitoso, el backend emitirá un token de autenticación (probablemente un JSON Web Token o JWT, que es un estándar de la industria). Este token representará la sesión del usuario y sus permisos de rol.
• Almacenamiento Seguro en el Frontend: La forma de almacenar el token es crítica para la seguridad:
    ◦ sessionStorage: Más seguro que localStorage porque los datos se borran cuando la sesión de la pestaña se cierra. Adecuado para sesiones más cortas.
    ◦ localStorage: Permite persistir la sesión entre cierres del navegador, lo que mejora la conveniencia del usuario. Sin embargo, es más vulnerable a ataques XSS (Cross-Site Scripting). Si se usa, es esencial tener estrictas medidas de seguridad XSS y considerar tiempos de expiración cortos para los tokens.
    ◦ Cookies HTTP-Only: Considerado el método más seguro para gestionar sesiones, especialmente si se usa con Secure y SameSite flags. El token se envía automáticamente en cada solicitud al backend sin que el JavaScript del frontend pueda acceder a él directamente, mitigando riesgos de XSS. El backend sería responsable de establecer estas cookies.
• Inclusión en los Headers de las Solicitudes a la API: Para cada solicitud subsiguiente al login que requiera autenticación, el token se incluirá en el encabezado Authorization como un token Bearer (ej., Authorization: Bearer <your_token>). Esto permitirá al backend verificar la identidad y los permisos del usuario antes de procesar la solicitud, garantizando el "control de acceso basado en roles".
